# -*- coding: utf-8 -*-
"""
Rotas da API para o m√≥dulo de Vendas (PDV)
"""

import logging
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import and_, or_, func, desc
from datetime import datetime, timedelta, date
from decimal import Decimal
from typing import List, Optional
from pydantic import BaseModel, Field
import json

from .db import get_session
from .auth import get_current_user
from .vendas_models import (
    Venda, VendaItem, VendaPagamento, VendaBaixa, ConfiguracaoEntrega
)
from .models import Cliente, User
from .produtos_models import Produto, ProdutoLote, EstoqueMovimentacao
from .financeiro_models import ContaReceber, FormaPagamento, LancamentoManual
from .audit_log import log_action

router = APIRouter(prefix="/vendas", tags=["vendas"])

# Configurar logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


# ============================================================================
# SCHEMAS PYDANTIC
# ============================================================================

class VendaItemSchema(BaseModel):
    tipo: str  # 'produto' ou 'servico'
    produto_id: Optional[int] = None
    servico_descricao: Optional[str] = None
    quantidade: float
    preco_unitario: float
    desconto_item: Optional[float] = 0
    subtotal: float
    lote_id: Optional[int] = None
    pet_id: Optional[int] = None  # Vincular item a um pet espec√≠fico

class VendaPagamentoSchema(BaseModel):
    forma_pagamento: str
    valor: float
    bandeira: Optional[str] = None
    numero_parcelas: Optional[int] = 1  # N√∫mero de parcelas para cart√£o de cr√©dito
    numero_transacao: Optional[str] = None
    numero_autorizacao: Optional[str] = None
    valor_recebido: Optional[float] = None
    troco: Optional[float] = None

class CriarVendaRequest(BaseModel):
    cliente_id: Optional[int] = None
    vendedor_id: Optional[int] = None
    funcionario_id: Optional[int] = None  # Funcion√°rio/Veterin√°rio que recebe comiss√£o
    itens: List[VendaItemSchema]
    desconto_valor: Optional[float] = 0
    desconto_percentual: Optional[float] = 0
    observacoes: Optional[str] = None
    tem_entrega: bool = False
    taxa_entrega: Optional[float] = 0
    entregador_id: Optional[int] = None
    loja_origem: Optional[str] = None
    endereco_entrega: Optional[str] = None
    distancia_km: Optional[float] = None
    valor_por_km: Optional[float] = None
    observacoes_entrega: Optional[str] = None

class FinalizarVendaRequest(BaseModel):
    pagamentos: List[VendaPagamentoSchema]

class CancelarVendaRequest(BaseModel):
    motivo: str

class ConfiguracaoEntregaSchema(BaseModel):
    valor_por_km: Optional[float] = None
    taxa_minima: Optional[float] = None
    raio_maximo_km: Optional[float] = None
    lojas: Optional[List[str]] = []
    google_maps_api_key: Optional[str] = None


# ============================================================================
# UTILIT√ÅRIOS
# ============================================================================

def gerar_numero_venda(db: Session, user_id: int) -> str:
    """Gera um n√∫mero sequencial para a venda"""
    hoje = datetime.now()
    prefixo = hoje.strftime('%Y%m%d')
    
    # Buscar √∫ltima venda do dia
    ultima_venda = db.query(Venda).filter(
        Venda.numero_venda.like(f'{prefixo}%'),
        Venda.user_id == user_id
    ).order_by(desc(Venda.numero_venda)).first()
    
    if ultima_venda:
        try:
            seq = int(ultima_venda.numero_venda[-4:]) + 1
        except:
            seq = 1
    else:
        seq = 1
    
    return f'{prefixo}{seq:04d}'


def calcular_totais_venda(itens: List[VendaItemSchema], desconto_valor=0, desconto_percentual=0, taxa_entrega=0):
    """
    Calcula os totais da venda
    
    üß† REGRA DE OURO: Frontend calcula desconto, Backend apenas soma
    - Subtotal dos itens J√Å vem com desconto aplicado
    - Backend N√ÉO recalcula desconto
    - Backend apenas soma: subtotal_itens + frete
    """
    print(f"\nüßÆ CALCULAR TOTAIS:")
    print(f"   Quantidade de itens: {len(itens)}")
    for idx, item in enumerate(itens):
        print(f"   Item {idx+1}: subtotal={item.subtotal}, qtd={item.quantidade}, preco={item.preco_unitario}")
    
    # ‚úÖ FRONTEND J√Å CALCULOU: Apenas soma subtotais (j√° com desconto aplicado)
    subtotal_itens = sum(item.subtotal for item in itens)
    print(f"   Subtotal itens (j√° com desconto): R$ {subtotal_itens:.2f}")
    print(f"   Frete: R$ {taxa_entrega:.2f}")
    
    # ‚úÖ Backend N√ÉO recalcula desconto - apenas soma
    total = subtotal_itens + taxa_entrega
    print(f"   Total final da venda: R$ {total:.2f}")
    
    return {
        'subtotal': float(subtotal_itens),
        'desconto_valor': 0,  # Desconto j√° est√° embutido no subtotal dos itens
        'total': float(total)
    }


def criar_contas_receber_da_venda(venda: Venda, pagamentos: List, db: Session, user_id: int):
    """
    Cria contas a receber automaticamente com base nos pagamentos da venda
    Considera prazo de recebimento de cada forma de pagamento
    Para cart√£o parcelado, cria m√∫ltiplas contas (uma por parcela) + lan√ßamentos manuais previstos
    """
    from decimal import Decimal
    from datetime import date, timedelta
    
    contas_criadas = []
    
    for pag in pagamentos:
        # Buscar configura√ß√£o da forma de pagamento
        forma_pag = db.query(FormaPagamento).filter(
            FormaPagamento.nome.ilike(f"%{pag.forma_pagamento}%")
        ).first()
        
        # Verificar se √© cart√£o parcelado
        numero_parcelas = getattr(pag, 'numero_parcelas', 1) or 1
        eh_cartao_parcelado = (
            forma_pag and 
            forma_pag.tipo == 'cartao_credito' and 
            numero_parcelas > 1
        )
        
        if eh_cartao_parcelado:
            # CART√ÉO PARCELADO: Criar m√∫ltiplas contas + lan√ßamentos
            # üêõ FIX: Usar pag.valor (valor pago no cart√£o) ao inv√©s de venda.total
            valor_total = Decimal(str(pag.valor))
            valor_parcela = valor_total / numero_parcelas
            
            # Buscar categoria de receitas (criar se n√£o existir)
            from .financeiro_models import CategoriaFinanceira
            categoria_receitas = db.query(CategoriaFinanceira).filter(
                CategoriaFinanceira.nome.ilike('%vendas%'),
                CategoriaFinanceira.tipo == 'receita'
            ).first()
            
            if not categoria_receitas:
                categoria_receitas = CategoriaFinanceira(
                    nome="Receitas de Vendas",
                    tipo="receita",
                    user_id=user_id
                )
                db.add(categoria_receitas)
                db.flush()
            
            for i in range(1, numero_parcelas + 1):
                data_vencimento = date.today() + timedelta(days=30 * i)
                
                # Criar lan√ßamento manual previsto
                lancamento = LancamentoManual(
                    tipo='entrada',
                    valor=valor_parcela,
                    descricao=f"Venda {venda.numero_venda} - Parcela {i}/{numero_parcelas} - {forma_pag.nome}",
                    data_lancamento=data_vencimento,
                    status='previsto',
                    categoria_id=categoria_receitas.id,
                    documento=f"VENDA-{venda.id}",
                    fornecedor_cliente=venda.cliente.nome if venda.cliente else None,
                    user_id=user_id
                )
                db.add(lancamento)
                db.flush()
                
                # Criar conta a receber
                conta = ContaReceber(
                    descricao=f"Venda {venda.numero_venda} - Parcela {i}/{numero_parcelas}",
                    cliente_id=venda.cliente_id,
                    forma_pagamento_id=forma_pag.id,
                    valor_original=valor_parcela,
                    valor_final=valor_parcela,
                    data_emissao=date.today(),
                    data_vencimento=data_vencimento,
                    venda_id=venda.id,
                    documento=f"VENDA-{venda.id}",
                    numero_parcela=i,
                    total_parcelas=numero_parcelas,
                    status='pendente',
                    user_id=user_id
                )
                
                db.add(conta)
                db.flush()
                contas_criadas.append(conta.id)
                
                print(f"üí≥ Parcela {i}/{numero_parcelas}: R$ {float(valor_parcela):.2f} - Venc: {data_vencimento}")
        
        else:
            # PAGAMENTO √Ä VISTA: Criar conta √∫nica APENAS SE FOR A PRAZO
            # Determinar data de vencimento
            prazo_dias = 0
            if forma_pag and forma_pag.prazo_dias:
                prazo_dias = forma_pag.prazo_dias
            elif pag.forma_pagamento.lower() in ['credito', 'cr√©dito', 'cartao_credito']:
                prazo_dias = 30  # Padr√£o cart√£o de cr√©dito
            elif pag.forma_pagamento.lower() in ['debito', 'd√©bito', 'pix', 'dinheiro']:
                prazo_dias = 0  # Recebimento imediato
            
            # üÜï L√ìGICA CORRIGIDA:
            # - √Ä vista (prazo=0): N√ÉO cria ContasReceber, s√≥ LancamentoManual
            # - A prazo (prazo>0): Cria ContasReceber + LancamentoManual previsto
            
            # CRIAR LAN√áAMENTO MANUAL NO FLUXO DE CAIXA (sempre)
            from .financeiro_models import CategoriaFinanceira
            
            categoria_receitas = db.query(CategoriaFinanceira).filter(
                CategoriaFinanceira.nome.ilike('%vendas%'),
                CategoriaFinanceira.tipo == 'receita'
            ).first()
            
            if not categoria_receitas:
                categoria_receitas = CategoriaFinanceira(
                    nome="Receitas de Vendas",
                    tipo="receita",
                    user_id=user_id
                )
                db.add(categoria_receitas)
                db.flush()
            
            # Status: realizado se prazo=0, previsto se tem prazo
            status_lancamento = 'realizado' if prazo_dias == 0 else 'previsto'
            data_lancamento = date.today() if prazo_dias == 0 else (date.today() + timedelta(days=prazo_dias))
            
            lancamento = LancamentoManual(
                tipo='entrada',
                valor=Decimal(str(pag.valor)),
                descricao=f"Venda {venda.numero_venda} - {pag.forma_pagamento}",
                data_lancamento=data_lancamento,
                status=status_lancamento,
                categoria_id=categoria_receitas.id,
                documento=f"VENDA-{venda.id}",
                fornecedor_cliente=venda.cliente.nome if venda.cliente else None,
                user_id=user_id
            )
            db.add(lancamento)
            db.flush()
            
            print(f"üí∞ Lan√ßamento {status_lancamento}: R$ {pag.valor:.2f} - {pag.forma_pagamento}")
            
            # CRIAR CONTA A RECEBER APENAS SE FOR A PRAZO (prazo > 0)
            if prazo_dias > 0:
                data_vencimento = date.today() + timedelta(days=prazo_dias)
                
                conta = ContaReceber(
                    descricao=f"Venda {venda.numero_venda} - {pag.forma_pagamento}",
                    cliente_id=venda.cliente_id,
                    forma_pagamento_id=forma_pag.id if forma_pag else None,
                    valor_original=Decimal(str(pag.valor)),
                    valor_recebido=Decimal('0'),
                    valor_final=Decimal(str(pag.valor)),
                    data_emissao=date.today(),
                    data_vencimento=data_vencimento,
                    data_recebimento=None,
                    status='pendente',
                    venda_id=venda.id,
                    user_id=user_id
                )
                db.add(conta)
                db.flush()
                contas_criadas.append(conta.id)
                print(f"üìã ContaReceber criada: R$ {pag.valor:.2f} - Venc: {data_vencimento}")
            else:
                # √Ä vista: n√£o cria ContasReceber
                print(f"‚úÖ Pagamento √† vista: R$ {pag.valor:.2f} - Sem ContasReceber")
            
            # üè¶ CRIAR MOVIMENTA√á√ÉO BANC√ÅRIA (se tiver conta banc√°ria vinculada)
            if forma_pag and forma_pag.conta_bancaria_destino_id and prazo_dias == 0:
                from .financeiro_models import MovimentacaoFinanceira, ContaBancaria
                
                conta_bancaria = db.query(ContaBancaria).get(forma_pag.conta_bancaria_destino_id)
                if conta_bancaria:
                    # Criar movimenta√ß√£o na conta banc√°ria
                    movimentacao = MovimentacaoFinanceira(
                        conta_bancaria_id=conta_bancaria.id,
                        tipo='entrada',
                        valor=Decimal(str(pag.valor)),
                        descricao=f"Venda {venda.numero_venda} - {pag.forma_pagamento}",
                        data_movimento=date.today(),
                        categoria_id=categoria_receitas.id,
                        status='realizado',
                        forma_pagamento_id=forma_pag.id,
                        documento=f"VENDA-{venda.id}",
                        origem_tipo='venda',
                        origem_id=venda.id,
                        origem_venda='fisica',
                        user_id=user_id
                    )
                    db.add(movimentacao)
                    
                    # Atualizar saldo da conta banc√°ria
                    conta_bancaria.saldo_atual += Decimal(str(pag.valor))
                    
                    print(f"üè¶ Movimenta√ß√£o banc√°ria: {conta_bancaria.nome} +R$ {pag.valor:.2f}")
    
    return contas_criadas


# ============================================================================
# ENDPOINTS - CONFIGURA√á√ïES DE ENTREGA
# ============================================================================

@router.get('/configuracoes-entrega')
def get_configuracao_entrega(
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Busca as configura√ß√µes de entrega"""
    config = db.query(ConfiguracaoEntrega).filter_by(user_id=current_user.id).first()
    
    if not config:
        return {
            'valor_por_km': None,
            'taxa_minima': None,
            'raio_maximo_km': None,
            'lojas': [],
            'google_maps_api_key': None
        }
    
    return config.to_dict()


@router.post('/configuracoes-entrega')
@router.put('/configuracoes-entrega')
def salvar_configuracao_entrega(
    dados: ConfiguracaoEntregaSchema,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Salva ou atualiza as configura√ß√µes de entrega"""
    config = db.query(ConfiguracaoEntrega).filter_by(user_id=current_user.id).first()
    
    if config:
        # Atualizar
        config.valor_por_km = dados.valor_por_km
        config.taxa_minima = dados.taxa_minima
        config.raio_maximo_km = dados.raio_maximo_km
        config.lojas = dados.lojas or []
        config.google_maps_api_key = dados.google_maps_api_key
        config.updated_at = datetime.now()
        
        log_action(db, current_user.id, 'UPDATE', 'configuracoes_entrega', config.id,
                   details='Configura√ß√µes de entrega atualizadas')
    else:
        # Criar
        config = ConfiguracaoEntrega(
            user_id=current_user.id,
            valor_por_km=dados.valor_por_km,
            taxa_minima=dados.taxa_minima,
            raio_maximo_km=dados.raio_maximo_km,
            lojas=dados.lojas or [],
            google_maps_api_key=dados.google_maps_api_key
        )
        db.add(config)
        
        log_action(db, current_user.id, 'CREATE', 'configuracoes_entrega', None,
                   details='Configura√ß√µes de entrega criadas')
    
    db.commit()
    db.refresh(config)
    
    return config.to_dict()


# ============================================================================
# ENDPOINTS - VENDAS CRUD
# ============================================================================

@router.get('')
def listar_vendas(
    page: int = Query(1, ge=1),
    per_page: int = Query(20, ge=1, le=5000),  # Aumentado limite para relat√≥rios
    status: Optional[str] = None,
    cliente_id: Optional[int] = None,
    data_inicio: Optional[str] = None,
    data_fim: Optional[str] = None,
    busca: Optional[str] = None,
    tem_entrega: Optional[bool] = None,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Lista as vendas com filtros"""
    try:
        query = db.query(Venda).options(
            joinedload(Venda.pagamentos),
            joinedload(Venda.cliente)  # Carregar relacionamento com cliente
        ).filter_by(user_id=current_user.id)
    except Exception as e:
        logger.error(f"‚ùå Erro ao criar query base: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erro ao criar query: {str(e)}")
    
    # Aplicar filtros
    if status:
        query = query.filter_by(status=status)
    
    if cliente_id:
        query = query.filter_by(cliente_id=cliente_id)
    
    if tem_entrega is not None:
        query = query.filter_by(tem_entrega=tem_entrega)
    
    if data_inicio:
        data_inicio_dt = datetime.strptime(data_inicio, '%Y-%m-%d')
        query = query.filter(Venda.data_venda >= data_inicio_dt)
    
    if data_fim:
        data_fim_dt = datetime.strptime(data_fim, '%Y-%m-%d')
        data_fim_dt = data_fim_dt.replace(hour=23, minute=59, second=59)
        query = query.filter(Venda.data_venda <= data_fim_dt)
    
    if busca:
        try:
            # Buscar por n√∫mero da venda, observa√ß√µes OU nome do cliente
            # SQLite: usar LIKE com lower() para case-insensitive
            busca_lower = f'%{busca.lower()}%'
            query = query.outerjoin(Cliente, Venda.cliente_id == Cliente.id).filter(
                or_(
                    Venda.numero_venda.contains(busca),
                    func.lower(Cliente.nome).like(busca_lower)
                )
            )
        except Exception as e:
            logger.error(f"‚ùå Erro ao aplicar filtro de busca: {str(e)}")
            raise HTTPException(status_code=500, detail=f"Erro na busca: {str(e)}")
    
    # Ordenar por data mais recente
    query = query.order_by(desc(Venda.data_venda))
    
    # Contar total
    total = query.count()
    
    # Paginar
    vendas = query.offset((page - 1) * per_page).limit(per_page).all()
    
    return {
        'vendas': [v.to_dict() for v in vendas],
        'total': total,
        'pages': (total + per_page - 1) // per_page,
        'current_page': page
    }


@router.get('/{venda_id}')
def buscar_venda(
    venda_id: int,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Busca uma venda espec√≠fica"""
    venda = db.query(Venda).filter_by(
        id=venda_id,
        user_id=current_user.id
    ).first()
    
    if not venda:
        raise HTTPException(status_code=404, detail='Venda n√£o encontrada')
    
    return venda.to_dict()


@router.post('')
def criar_venda(
    dados: CriarVendaRequest,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Cria uma nova venda"""
    # Valida√ß√µes
    if not dados.itens or len(dados.itens) == 0:
        raise HTTPException(status_code=400, detail='A venda deve ter pelo menos um item')
    
    print(f"\nüì• DADOS RECEBIDOS NO BACKEND:")
    print(f"   üß† Frontend j√° calculou descontos - Backend apenas valida e soma")
    print(f"   üîç DEBUG funcionario_id recebido: {dados.funcionario_id}")
    print(f"   üîç DEBUG tipo: {type(dados.funcionario_id)}")
    print(f"   Funcion√°rio/Veterin√°rio (comiss√£o): {dados.funcionario_id or 'Nenhum'}")
    print(f"   Quantidade de itens: {len(dados.itens)}")
    for idx, item in enumerate(dados.itens):
        print(f"   Item {idx+1}: subtotal={item.subtotal} (j√° com desconto aplicado)")
    
    # Gerar n√∫mero da venda
    numero_venda = gerar_numero_venda(db, current_user.id)
    
    # Calcular totais
    totais = calcular_totais_venda(
        dados.itens,
        dados.desconto_valor or 0,
        dados.desconto_percentual or 0,
        dados.taxa_entrega or 0
    )
    
    # Criar venda
    print(f"\nüèóÔ∏è CRIANDO VENDA:")
    print(f"   funcionario_id que ser√° salvo: {dados.funcionario_id}")
    
    venda = Venda(
        numero_venda=numero_venda,
        cliente_id=dados.cliente_id,
        vendedor_id=dados.vendedor_id or current_user.id,
        funcionario_id=dados.funcionario_id,  # Funcion√°rio/Veterin√°rio que recebe comiss√£o
        subtotal=totais['subtotal'],
        desconto_valor=totais['desconto_valor'],
        desconto_percentual=dados.desconto_percentual or 0,
        total=totais['total'],
        observacoes=dados.observacoes,
        tem_entrega=dados.tem_entrega,
        taxa_entrega=dados.taxa_entrega or 0,
        entregador_id=dados.entregador_id,
        loja_origem=dados.loja_origem,
        endereco_entrega=dados.endereco_entrega,
        distancia_km=dados.distancia_km,
        valor_por_km=dados.valor_por_km,
        observacoes_entrega=dados.observacoes_entrega,
        status_entrega='pendente' if dados.tem_entrega else None,
        status='aberta',
        data_venda=datetime.now(),
        user_id=current_user.id
    )
    
    db.add(venda)
    db.flush()  # Para obter o ID
    
    print(f"\n‚úÖ VENDA CRIADA:")
    print(f"   ID: {venda.id}")
    print(f"   funcionario_id salvo: {venda.funcionario_id}")
    
    # Criar itens
    for item_data in dados.itens:
        item = VendaItem(
            venda_id=venda.id,
            tipo=item_data.tipo,
            produto_id=item_data.produto_id,
            servico_descricao=item_data.servico_descricao,
            quantidade=item_data.quantidade,
            preco_unitario=item_data.preco_unitario,
            desconto_item=item_data.desconto_item or 0,
            subtotal=item_data.subtotal,
            lote_id=item_data.lote_id,
            pet_id=item_data.pet_id  # Vincular item ao pet
        )
        db.add(item)
    
    db.commit()
    db.refresh(venda)
    
    print(f"\nüîç AP√ìS PRIMEIRO COMMIT:")
    print(f"   funcionario_id da venda: {venda.funcionario_id}")
    
    # üÜï CRIAR CONTAS A RECEBER E LAN√áAMENTO PREVISTO PARA VENDA EM ABERTO
    # Quando venda √© salva sem pagamento, j√° registra a expectativa de recebimento
    from decimal import Decimal
    from datetime import date, timedelta
    from app.financeiro_models import ContaReceber, LancamentoManual, CategoriaFinanceira
    
    # Buscar categoria de receitas
    categoria_receitas = db.query(CategoriaFinanceira).filter(
        CategoriaFinanceira.nome.ilike('%vendas%'),
        CategoriaFinanceira.tipo == 'receita'
    ).first()
    
    if not categoria_receitas:
        categoria_receitas = CategoriaFinanceira(
            nome="Receitas de Vendas",
            tipo="receita",
            user_id=current_user.id
        )
        db.add(categoria_receitas)
        db.flush()
    
    # Criar lan√ßamento previsto (30 dias)
    prazo_dias = 30
    data_prevista = date.today() + timedelta(days=prazo_dias)
    
    lancamento = LancamentoManual(
        tipo='entrada',
        valor=Decimal(str(venda.total)),
        descricao=f"Venda {venda.numero_venda} - A receber",
        data_lancamento=data_prevista,
        status='previsto',
        categoria_id=categoria_receitas.id,
        documento=f"VENDA-{venda.id}",
        fornecedor_cliente=venda.cliente.nome if venda.cliente else "Cliente Avulso",
        user_id=current_user.id
    )
    db.add(lancamento)
    db.flush()
    
    # Criar conta a receber
    conta_receber = ContaReceber(
        descricao=f"Venda {venda.numero_venda}",
        cliente_id=venda.cliente_id,
        valor_original=Decimal(str(venda.total)),
        valor_recebido=Decimal('0'),
        valor_final=Decimal(str(venda.total)),
        data_emissao=date.today(),
        data_vencimento=data_prevista,
        status='pendente',
        venda_id=venda.id,
        user_id=current_user.id
    )
    db.add(conta_receber)
    db.commit()
    
    print(f"üìä Venda em aberto: ContasReceber + Lan√ßamento previsto criados (R$ {venda.total:.2f} em {data_prevista})")
    
    log_action(db, current_user.id, 'CREATE', 'vendas', venda.id,
               details=f'Venda {numero_venda} criada - Total: R$ {totais["total"]:.2f}')
    
    return venda.to_dict()


@router.put('/{venda_id}')
def atualizar_venda(
    venda_id: int,
    dados: CriarVendaRequest,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Atualiza uma venda existente (somente vendas abertas)"""
    # Buscar venda
    venda = db.query(Venda).filter_by(
        id=venda_id,
        user_id=current_user.id
    ).first()
    
    if not venda:
        raise HTTPException(status_code=404, detail='Venda n√£o encontrada')
    
    # S√≥ permite atualizar vendas abertas
    if venda.status != 'aberta':
        raise HTTPException(
            status_code=400, 
            detail=f'N√£o √© poss√≠vel atualizar venda com status "{venda.status}". Apenas vendas abertas podem ser atualizadas.'
        )
    
    # Valida√ß√µes
    if not dados.itens or len(dados.itens) == 0:
        raise HTTPException(status_code=400, detail='A venda deve ter pelo menos um item')
    
    # Calcular novos totais
    totais = calcular_totais_venda(
        dados.itens,
        dados.desconto_valor or 0,
        dados.desconto_percentual or 0,
        dados.taxa_entrega or 0
    )
    
    print(f"\nüîÑ ATUALIZANDO VENDA {venda_id}:")
    print(f"   funcionario_id recebido: {dados.funcionario_id}")
    print(f"   funcionario_id anterior: {venda.funcionario_id}")
    
    # Atualizar campos da venda
    venda.cliente_id = dados.cliente_id
    venda.vendedor_id = dados.vendedor_id or current_user.id
    venda.funcionario_id = dados.funcionario_id  # ‚úÖ Funcion√°rio/Veterin√°rio que recebe comiss√£o
    
    print(f"   funcionario_id novo: {venda.funcionario_id}")
    
    venda.subtotal = totais['subtotal']
    venda.desconto_valor = totais['desconto_valor']
    venda.desconto_percentual = dados.desconto_percentual or 0
    venda.total = totais['total']
    venda.observacoes = dados.observacoes
    venda.tem_entrega = dados.tem_entrega
    venda.taxa_entrega = dados.taxa_entrega or 0
    venda.entregador_id = dados.entregador_id
    venda.loja_origem = dados.loja_origem
    venda.endereco_entrega = dados.endereco_entrega
    venda.distancia_km = dados.distancia_km
    venda.valor_por_km = dados.valor_por_km
    venda.observacoes_entrega = dados.observacoes_entrega
    venda.status_entrega = 'pendente' if dados.tem_entrega else None
    venda.updated_at = datetime.now()
    
    # Excluir itens antigos
    db.query(VendaItem).filter_by(venda_id=venda.id).delete()
    
    # Criar novos itens
    for item_data in dados.itens:
        item = VendaItem(
            venda_id=venda.id,
            tipo=item_data.tipo,
            produto_id=item_data.produto_id,
            servico_descricao=item_data.servico_descricao,
            quantidade=item_data.quantidade,
            preco_unitario=item_data.preco_unitario,
            desconto_item=item_data.desconto_item or 0,
            subtotal=item_data.subtotal,
            lote_id=item_data.lote_id,
            pet_id=item_data.pet_id
        )
        db.add(item)
    
    db.commit()
    db.refresh(venda)
    
    log_action(db, current_user.id, 'update', 'vendas', venda.id,
               details=f'Venda {venda.numero_venda} atualizada - Total: R$ {totais["total"]:.2f}')
    
    return venda.to_dict()


@router.post('/{venda_id}/finalizar')
def finalizar_venda(
    venda_id: int,
    dados: FinalizarVendaRequest,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Finaliza uma venda com os pagamentos"""
    
    # üîí HARDENING 1: Transa√ß√£o at√¥mica com rollback autom√°tico
    logger.info(f"üîÑ FINALIZE_START - Venda #{venda_id} | User: {current_user.id}")
    
    try:
        # ‚ö†Ô∏è VALIDA√á√ÉO CR√çTICA: Verificar se h√° caixa aberto ANTES de qualquer opera√ß√£o
        from app.caixa_models import Caixa, MovimentacaoCaixa
        
        caixa_aberto = db.query(Caixa).filter(
            Caixa.usuario_id == current_user.id,
            Caixa.status == 'aberto'
        ).first()
        
        if not caixa_aberto:
            raise HTTPException(
                status_code=400,
                detail='N√£o √© poss√≠vel finalizar vendas sem um caixa aberto. Por favor, abra o caixa primeiro.'
            )
        
        venda = db.query(Venda).filter_by(
            id=venda_id,
            user_id=current_user.id
        ).first()
        
        if not venda:
            raise HTTPException(status_code=404, detail='Venda n√£o encontrada')
        
        # üîí VALIDA√á√ÉO: Bloquear finaliza√ß√£o duplicada via status
        logger.info(f"üìä Venda #{venda_id} - Status atual: {venda.status}")
        
        if venda.status not in ['aberta', 'baixa_parcial']:
            logger.warning(f"‚ö†Ô∏è Tentativa de finalizar venda #{venda_id} com status '{venda.status}'")
            raise HTTPException(status_code=400, detail=f'Apenas vendas abertas ou com baixa parcial podem receber pagamentos (status atual: {venda.status})')
        
        if not dados.pagamentos:
            raise HTTPException(status_code=400, detail='Informe pelo menos uma forma de pagamento')
        
        # Calcular total j√° pago anteriormente
        pagamentos_existentes = db.query(VendaPagamento).filter_by(venda_id=venda.id).all()
        total_ja_pago = sum(float(p.valor) for p in pagamentos_existentes)
        
        # Calcular valor restante a pagar
        total_venda = float(venda.total)
        valor_restante = total_venda - total_ja_pago
        
        # Verificar se venda j√° est√° totalmente paga
        if abs(valor_restante) < 0.01:
            raise HTTPException(status_code=400, detail='Venda j√° est√° totalmente paga')
        
        # Calcular novo total de pagamentos
        total_novos_pagamentos = sum(p.valor for p in dados.pagamentos)
        
        # Verificar se n√£o est√° pagando a mais
        if total_novos_pagamentos > valor_restante + 0.01:
            logger.error(f"‚ùå ERRO: Pagamento maior que restante - Venda #{venda_id}")
            logger.error(f"   Total venda: R$ {total_venda:.2f}")
            logger.error(f"   J√° pago: R$ {total_ja_pago:.2f}")
            logger.error(f"   Restante: R$ {valor_restante:.2f}")
            logger.error(f"   Novos pagamentos: R$ {total_novos_pagamentos:.2f}")
            raise HTTPException(
                status_code=400, 
                detail=f'Valor dos pagamentos (R$ {total_novos_pagamentos:.2f}) ultrapassa o valor restante (R$ {valor_restante:.2f})'
            )
        
        total_pagamentos = total_ja_pago + total_novos_pagamentos
        
        # Criar novos pagamentos E registrar no caixa
        # (caixa_aberto j√° foi validado no in√≠cio da fun√ß√£o)
        
        for pag_data in dados.pagamentos:
        pagamento = VendaPagamento(
            venda_id=venda.id,
            forma_pagamento=pag_data.forma_pagamento,
            valor=pag_data.valor,
            bandeira=pag_data.bandeira,
            numero_parcelas=pag_data.numero_parcelas or 1,
            numero_transacao=pag_data.numero_transacao,
            numero_autorizacao=pag_data.numero_autorizacao,
            valor_recebido=pag_data.valor_recebido,
            troco=pag_data.troco,
            status='confirmado',
            data_pagamento=datetime.now()
        )
        db.add(pagamento)
        
        # üéÅ CR√âDITO CLIENTE: Deduzir do saldo sem movimenta√ß√µes
        forma_eh_credito = (
            pag_data.forma_pagamento == 'credito_cliente' or
            pag_data.forma_pagamento == 'Cr√©dito Cliente' or
            str(pag_data.forma_pagamento).lower() == 'credito_cliente'
        )
        
        if forma_eh_credito:
            # Validar que venda possui cliente
            if not venda.cliente_id:
                raise HTTPException(
                    status_code=400,
                    detail='Cr√©dito s√≥ pode ser usado em vendas com cliente vinculado'
                )
            
            # Validar saldo de cr√©dito
            cliente = db.query(Cliente).filter_by(id=venda.cliente_id).first()
            if not cliente:
                raise HTTPException(status_code=404, detail='Cliente n√£o encontrado')
            
            credito_disponivel = float(cliente.credito or 0)
            
            if pag_data.valor > credito_disponivel + 0.01:
                raise HTTPException(
                    status_code=400,
                    detail=f'Cr√©dito insuficiente. Dispon√≠vel: R$ {credito_disponivel:.2f}'
                )
            
            # Deduzir do cr√©dito do cliente
            cliente.credito = Decimal(str(credito_disponivel - pag_data.valor))
            db.add(cliente)
            
            logger.info(f"üéÅ Cr√©dito utilizado: R$ {pag_data.valor:.2f} - Saldo restante: R$ {float(cliente.credito):.2f}")
            
            # N√ÉO criar MovimentacaoCaixa nem LancamentoManual para cr√©dito
            continue
        
        # üîß CORRE√á√ÉO: Registrar movimenta√ß√£o no caixa APENAS para DINHEIRO EM ESP√âCIE
        # Caixa f√≠sico = apenas dinheiro. PIX/D√©bito/Cr√©dito v√£o para banco/financeiro
        
        # Verificar se √© dinheiro (pode vir como ID=1 ou nome="Dinheiro")
        forma_eh_dinheiro = (
            pag_data.forma_pagamento == 'Dinheiro' or 
            pag_data.forma_pagamento == 1 or
            str(pag_data.forma_pagamento) == '1'
        )
        
        logger.debug(f"DEBUG CAIXA: forma={pag_data.forma_pagamento}, eh_dinheiro={forma_eh_dinheiro}, caixa_aberto={caixa_aberto.id if caixa_aberto else None}")
        
        if caixa_aberto and forma_eh_dinheiro:
            movimentacao_caixa = MovimentacaoCaixa(
                caixa_id=caixa_aberto.id,
                tipo='venda',
                valor=pag_data.valor,
                forma_pagamento='Dinheiro',  # Sempre salvar como "Dinheiro" (n√£o ID)
                descricao=f'Venda #{venda.numero_venda}',
                venda_id=venda.id,
                usuario_id=current_user.id,
                usuario_nome=current_user.nome
            )
            db.add(movimentacao_caixa)
            logger.info(f"‚úÖ Movimenta√ß√£o de caixa registrada: Dinheiro - R$ {pag_data.valor:.2f}")
    
    # Atualizar status da venda
    if abs(total_pagamentos - total_venda) < 0.01:
        # Pagamento completo
        venda.status = 'finalizada'
        venda.data_finalizacao = datetime.now()
        # Vincular venda ao caixa
        if not venda.caixa_id:
            venda.caixa_id = caixa_aberto.id
    elif total_pagamentos > 0:
        # Pagamento parcial - criar lan√ßamento previsto para o saldo
        venda.status = 'baixa_parcial'
        # Vincular venda ao caixa tamb√©m em baixa parcial
        if not venda.caixa_id:
            venda.caixa_id = caixa_aberto.id
        
        # üÜï CRIAR LAN√áAMENTO PREVISTO PARA O SALDO EM ABERTO
        from app.financeiro_models import LancamentoManual, CategoriaFinanceira
        
        saldo_em_aberto = total_venda - total_pagamentos
        
        if saldo_em_aberto > 0.01:  # Evitar centavos
            # Buscar categoria de receitas
            categoria_receitas = db.query(CategoriaFinanceira).filter(
                CategoriaFinanceira.nome.ilike('%vendas%'),
                CategoriaFinanceira.tipo == 'receita'
            ).first()
            
            if not categoria_receitas:
                categoria_receitas = CategoriaFinanceira(
                    nome="Receitas de Vendas",
                    tipo="receita",
                    user_id=current_user.id
                )
                db.add(categoria_receitas)
                db.flush()
            
            # Criar lan√ßamento previsto (30 dias padr√£o)
            prazo_dias = 30
            data_prevista = date.today() + timedelta(days=prazo_dias)
            
            lancamento_saldo = LancamentoManual(
                tipo='entrada',
                valor=Decimal(str(saldo_em_aberto)),
                descricao=f"Venda {venda.numero_venda} - Saldo em aberto",
                data_lancamento=data_prevista,
                status='previsto',
                categoria_id=categoria_receitas.id,
                documento=f"VENDA-{venda.id}-SALDO",
                fornecedor_cliente=venda.cliente.nome if venda.cliente else "Cliente Avulso",
                user_id=current_user.id
            )
            db.add(lancamento_saldo)
            logger.info(f"üìä Lan√ßamento previsto criado para saldo: R$ {saldo_em_aberto:.2f} em {data_prevista}")
    else:
        # Permanece aberta
        venda.status = 'aberta'
    
    venda.updated_at = datetime.now()
    
    # Baixar estoque dos produtos E criar movimenta√ß√µes
    for item in venda.itens:
        if item.tipo == 'produto' and item.produto_id:
            produto = db.query(Produto).get(item.produto_id)
            if produto:
                estoque_anterior = produto.estoque_atual or 0
                quantidade_vendida = float(item.quantidade)
                
                # FIFO: Consumir lotes se existirem
                lotes_consumidos = []
                lotes_ativos = db.query(ProdutoLote).filter(
                    ProdutoLote.produto_id == produto.id,
                    ProdutoLote.quantidade_disponivel > 0,
                    ProdutoLote.status == 'ativo'
                ).order_by(ProdutoLote.ordem_entrada).all()
                
                if lotes_ativos:
                    quantidade_restante = quantidade_vendida
                    for lote in lotes_ativos:
                        if quantidade_restante <= 0:
                            break
                        
                        saldo_anterior = lote.quantidade_disponivel  # Guardar saldo antes de consumir
                        qtd_consumir = min(lote.quantidade_disponivel, quantidade_restante)
                        lote.quantidade_disponivel -= qtd_consumir
                        quantidade_restante -= qtd_consumir
                        
                        if lote.quantidade_disponivel == 0:
                            lote.status = 'esgotado'
                        
                        lotes_consumidos.append({
                            "lote_id": lote.id,
                            "nome_lote": lote.nome_lote,
                            "quantidade": qtd_consumir,
                            "saldo_anterior": saldo_anterior  # Para mostrar (X/Y)
                        })
                
                # Baixar estoque
                produto.estoque_atual -= quantidade_vendida
                
                # Criar movimenta√ß√£o de estoque
                movimentacao = EstoqueMovimentacao(
                    produto_id=produto.id,
                    tipo='saida',
                    motivo='venda',
                    quantidade=quantidade_vendida,
                    quantidade_anterior=estoque_anterior,
                    quantidade_nova=produto.estoque_atual,
                    custo_unitario=produto.preco_custo,
                    valor_total=quantidade_vendida * (produto.preco_custo or 0),
                    lotes_consumidos=json.dumps(lotes_consumidos) if lotes_consumidos else None,
                    documento=None,  # S√≥ preencher quando houver NF emitida
                    referencia_id=venda.id,
                    referencia_tipo='venda',
                    observacao=None,  # Observa√ß√£o fica vazia para vendas
                    user_id=current_user.id
                )
                db.add(movimentacao)
    
    # üÜï BAIXAR CONTAS A RECEBER E LAN√áAMENTOS ORIGINAIS (se venda estava em aberto)
    # Quando venda √© finalizada/parcialmente paga, baixar os lan√ßamentos previstos originais
    from app.financeiro_models import ContaReceber, LancamentoManual, Recebimento, FormaPagamento
    
    # Buscar TODAS as contas relacionadas √† venda que n√£o est√£o totalmente pagas
    contas_originais = db.query(ContaReceber).filter(
        ContaReceber.venda_id == venda.id,
        ContaReceber.status.in_(['pendente', 'parcial', 'vencido'])
    ).all()
    
    if contas_originais:
        # Calcular quanto ainda resta pagar ap√≥s os pagamentos existentes anteriores
        saldo_venda = total_venda - total_ja_pago
        valor_disponivel_baixa = total_novos_pagamentos
        
        logger.info(f"üí∞ Baixando contas: saldo_venda={saldo_venda:.2f}, novos_pagamentos={valor_disponivel_baixa:.2f}")
        
        for conta in contas_originais:
            if valor_disponivel_baixa <= 0:
                break
                
            # Calcular quanto ainda falta nesta conta
            valor_pendente_conta = float(conta.valor_final) - float(conta.valor_recebido or 0)
            
            # Calcular quanto pode baixar desta conta
            valor_a_baixar = min(valor_pendente_conta, valor_disponivel_baixa)
            
            if valor_a_baixar > 0.01:
                # Atualizar valor recebido
                novo_valor_recebido = float(conta.valor_recebido or 0) + valor_a_baixar
                conta.valor_recebido = Decimal(str(novo_valor_recebido))
                
                # üÜï CRIAR REGISTRO DE RECEBIMENTO (para aparecer no fluxo de caixa)
                # Buscar forma de pagamento (usar a primeira do pagamento)
                forma_pag_id = None
                if dados.pagamentos:
                    primeiro_pag = dados.pagamentos[0]
                    forma_pag = db.query(FormaPagamento).filter(
                        FormaPagamento.nome.ilike(f"%{primeiro_pag.forma_pagamento}%")
                    ).first()
                    if forma_pag:
                        forma_pag_id = forma_pag.id
                
                recebimento = Recebimento(
                    conta_receber_id=conta.id,
                    valor_recebido=Decimal(str(valor_a_baixar)),
                    data_recebimento=date.today(),
                    forma_pagamento_id=forma_pag_id,
                    observacoes=f"Recebimento venda #{venda.numero_venda}",
                    user_id=current_user.id
                )
                db.add(recebimento)
                db.flush()
                
                # Atualizar status
                if abs(novo_valor_recebido - float(conta.valor_final)) < 0.01:
                    # Conta totalmente paga
                    conta.status = 'recebido'
                    conta.data_recebimento = date.today()
                    logger.info(f"‚úÖ ContaReceber #{conta.id} TOTALMENTE baixada - R$ {valor_a_baixar:.2f} (Recebimento #{recebimento.id} criado)")
                else:
                    # Conta parcialmente paga
                    conta.status = 'parcial'
                    logger.info(f"üìä ContaReceber #{conta.id} baixa PARCIAL - R$ {valor_a_baixar:.2f} (total recebido: R$ {novo_valor_recebido:.2f}, Recebimento #{recebimento.id} criado)")
                
                # Diminuir valor dispon√≠vel para pr√≥ximas contas
                valor_disponivel_baixa -= valor_a_baixar
                db.add(conta)
        
        logger.info(f"üéØ Contas a receber atualizadas - {len(contas_originais)} conta(s) processada(s)")
        
        # üÜï BAIXAR LAN√áAMENTOS MANUAIS PREVISTOS (associados √† venda)
        # Buscar lan√ßamentos previstos criados quando a venda foi salva em aberto
        lancamentos_previstos = db.query(LancamentoManual).filter(
            LancamentoManual.documento == f"VENDA-{venda.id}",
            LancamentoManual.status == 'previsto',
            LancamentoManual.tipo == 'entrada'
        ).all()
        
        if lancamentos_previstos:
            # Calcular quanto do lan√ßamento previsto foi realizado
            total_recebido_venda = total_ja_pago + total_novos_pagamentos
            
            for lanc_prev in lancamentos_previstos:
                valor_previsto_original = float(lanc_prev.valor)
                
                # Se recebeu tudo, marcar como realizado
                if abs(total_recebido_venda - total_venda) < 0.01:
                    lanc_prev.status = 'realizado'
                    lanc_prev.data_lancamento = date.today()
                    db.add(lanc_prev)
                    logger.info(f"‚úÖ Lan√ßamento previsto #{lanc_prev.id} marcado como REALIZADO (venda totalmente paga)")
                
                # Se recebeu parcialmente, criar novo lan√ßamento realizado proporcional
                elif total_recebido_venda > 0.01:
                    # Criar lan√ßamento realizado com o valor recebido
                    lanc_realizado = LancamentoManual(
                        tipo='entrada',
                        valor=Decimal(str(total_recebido_venda)),
                        descricao=f"Venda {venda.numero_venda} - Recebido (parcial)",
                        data_lancamento=date.today(),
                        status='realizado',
                        categoria_id=lanc_prev.categoria_id,
                        documento=f"VENDA-{venda.id}-REALIZADO",
                        fornecedor_cliente=lanc_prev.fornecedor_cliente,
                        user_id=current_user.id
                    )
                    db.add(lanc_realizado)
                    
                    # Ajustar o lan√ßamento previsto para o saldo restante
                    saldo_restante = total_venda - total_recebido_venda
                    if saldo_restante > 0.01:
                        lanc_prev.valor = Decimal(str(saldo_restante))
                        db.add(lanc_prev)
                        logger.info(f"üìä Lan√ßamento previsto #{lanc_prev.id} ajustado para R$ {saldo_restante:.2f} (saldo restante)")
                        logger.info(f"‚úÖ Lan√ßamento realizado #{lanc_realizado.id} criado - R$ {total_recebido_venda:.2f}")
                    else:
                        # Excluir lan√ßamento previsto se n√£o h√° mais saldo
                        db.delete(lanc_prev)
                        logger.info(f"üóëÔ∏è Lan√ßamento previsto #{lanc_prev.id} exclu√≠do (venda totalmente paga)")
                        logger.info(f"‚úÖ Lan√ßamento realizado #{lanc_realizado.id} criado - R$ {total_recebido_venda:.2f}")
    
    # ‚öñÔ∏è COMMIT PARCIAL - Opera√ß√µes essenciais (venda, pagamentos, estoque, caixa)
    # Se commit falhar aqui, tudo deve ser revertido
    db.commit()
    logger.info(f"‚úÖ Opera√ß√µes essenciais commitadas - Venda #{venda_id}")
    
    # üîí Opera√ß√µes SECUND√ÅRIAS (podem falhar sem abortar a venda)
    # CRIAR CONTAS A RECEBER automaticamente
    contas_ids = []
    try:
        contas_ids = criar_contas_receber_da_venda(venda, dados.pagamentos, db, current_user.id)
        logger.info(f"‚úÖ {len(contas_ids)} contas a receber criadas para venda {venda.numero_venda}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Erro ao criar contas a receber (venda {venda.id}): {str(e)}", exc_info=True)
        # N√£o abortar a finaliza√ß√£o da venda por erro nas contas
    
    # üÜï GERAR COMISS√ïES AUTOMATICAMENTE (apenas se funcion√°rio/veterin√°rio foi selecionado)
    if venda.funcionario_id:
        try:
            from app.comissoes_service import gerar_comissoes_venda
            
            # Se foi pagamento parcial, passar valor pago
            valor_pago_agora = Decimal(str(total_novos_pagamentos)) if total_novos_pagamentos > 0 else None
            
            logger.info(f"üîÑ Gerando comiss√µes - Venda #{venda.id} | Funcion√°rio: {venda.funcionario_id}")
            
            resultado = gerar_comissoes_venda(
                venda_id=venda.id,
                funcionario_id=venda.funcionario_id,
                valor_pago=valor_pago_agora,
                db=db
            )
            
            if resultado and resultado.get('success'):
                total_com = resultado.get('total_comissao', 0)
                logger.info(f"‚úÖ Comiss√µes geradas: R$ {total_com:.2f}")
                if resultado.get('duplicated'):
                    logger.warning(f"‚ö†Ô∏è Comiss√µes j√° existiam (idempotente) - Venda #{venda.id}")
            else:
                logger.info("‚ÑπÔ∏è  Nenhuma comiss√£o gerada (sem configura√ß√£o)")
                
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Erro ao gerar comiss√µes (venda {venda.id}): {str(e)}", exc_info=True)
            # N√£o abortar a finaliza√ß√£o da venda por erro nas comiss√µes
    else:
        logger.info("‚ÑπÔ∏è  Venda sem funcion√°rio - comiss√µes n√£o geradas")
    
    # üîî SISTEMA DE RECORR√äNCIA - Criar/Atualizar lembretes automaticamente
    from app.produtos_models import Lembrete
    from app.models import Pet
    
    lembretes_criados = []
    lembretes_atualizados = []
    
    try:
        for item in venda.itens:
            # Apenas produtos com pet_id vinculado e que tenham recorr√™ncia
            if item.tipo == 'produto' and item.produto_id and item.pet_id:
                produto = db.query(Produto).get(item.produto_id)
                pet = db.query(Pet).get(item.pet_id)
                
                if produto and pet and produto.tem_recorrencia and produto.intervalo_dias:
                    # Verificar se j√° existe lembrete PENDENTE para este produto+pet
                    lembrete_existente = db.query(Lembrete).filter(
                        Lembrete.cliente_id == venda.cliente_id,
                        Lembrete.pet_id == item.pet_id,
                        Lembrete.produto_id == item.produto_id,
                        Lembrete.status.in_(['pendente', 'notificado'])
                    ).first()
                    
                    if lembrete_existente:
                        # ‚úÖ CLIENTE J√Å TINHA LEMBRETE - DAR CHECK AUTOM√ÅTICO
                        historico = json.loads(lembrete_existente.historico_doses) if lembrete_existente.historico_doses else []
                        historico.append({
                            "dose": lembrete_existente.dose_atual,
                            "data": datetime.utcnow().isoformat(),
                            "comprou": True,
                            "status": "completado",
                            "venda_id": venda.id
                        })
                        
                        # Marcar como completado
                        lembrete_existente.status = 'completado'
                        lembrete_existente.data_completado = datetime.utcnow()
                        lembrete_existente.historico_doses = json.dumps(historico)
                        
                        # Verificar se √© a √∫ltima dose
                        if lembrete_existente.dose_total and lembrete_existente.dose_atual >= lembrete_existente.dose_total:
                            # √öltima dose - N√ÉO criar novo lembrete
                            lembretes_atualizados.append({
                                "acao": "finalizado",
                                "produto": produto.nome,
                                "pet": pet.nome,
                                "dose": f"{lembrete_existente.dose_atual}/{lembrete_existente.dose_total}"
                            })
                        else:
                            # Criar novo lembrete para pr√≥xima dose
                            data_proxima = datetime.utcnow() + timedelta(days=produto.intervalo_dias)
                            data_notificacao = data_proxima - timedelta(days=7)
                            
                            novo_lembrete = Lembrete(
                                user_id=current_user.id,
                                cliente_id=venda.cliente_id,
                                pet_id=item.pet_id,
                                produto_id=item.produto_id,
                                venda_id=venda.id,
                                data_compra=datetime.utcnow(),
                                data_proxima_dose=data_proxima,
                                data_notificacao_7_dias=data_notificacao,
                                status='pendente',
                                quantidade_recomendada=float(item.quantidade),
                                preco_estimado=produto.preco_venda,
                                dose_atual=lembrete_existente.dose_atual + 1,
                                dose_total=lembrete_existente.dose_total,
                                historico_doses=json.dumps(historico)
                            )
                            db.add(novo_lembrete)
                            
                            lembretes_atualizados.append({
                                "acao": "renovado",
                                "produto": produto.nome,
                                "pet": pet.nome,
                                "dose": f"{novo_lembrete.dose_atual}/{novo_lembrete.dose_total or '‚àû'}"
                            })
                    else:
                        # ‚ú® PRIMEIRA VENDA COM RECORR√äNCIA - CRIAR LEMBRETE
                        data_proxima = datetime.utcnow() + timedelta(days=produto.intervalo_dias)
                        data_notificacao = data_proxima - timedelta(days=7)
                        
                        historico_inicial = [{
                            "dose": 1,
                            "data": datetime.utcnow().isoformat(),
                            "comprou": True,
                            "status": "criado",
                            "venda_id": venda.id
                        }]
                        
                        novo_lembrete = Lembrete(
                            user_id=current_user.id,
                            cliente_id=venda.cliente_id,
                            pet_id=item.pet_id,
                            produto_id=item.produto_id,
                            venda_id=venda.id,
                            data_compra=datetime.utcnow(),
                            data_proxima_dose=data_proxima,
                            data_notificacao_7_dias=data_notificacao,
                            status='pendente',
                            quantidade_recomendada=float(item.quantidade),
                            preco_estimado=produto.preco_venda,
                            dose_atual=1,
                            dose_total=produto.numero_doses,
                            historico_doses=json.dumps(historico_inicial)
                        )
                        db.add(novo_lembrete)
                        
                        lembretes_criados.append({
                            "produto": produto.nome,
                            "pet": pet.nome,
                            "proxima_dose": data_proxima.strftime("%d/%m/%Y"),
                            "dose_total": produto.numero_doses or "‚àû"
                        })
        
        if lembretes_criados or lembretes_atualizados:
            logger.info(f"üîî Lembretes: {len(lembretes_criados)} criados, {len(lembretes_atualizados)} atualizados")
    
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Erro ao processar lembretes: {str(e)}")
        # N√£o abortar a venda por erro nos lembretes
    
    db.commit()
    db.refresh(venda)
    
    log_action(db, current_user.id, 'UPDATE', 'vendas', venda.id,
               details=f'Venda {venda.numero_venda} finalizada - Total: R$ {float(venda.total):.2f}')
    
    # ‚úÖ LOG DE SUCESSO
    logger.info(f"‚úÖ FINALIZE_SUCCESS - Venda #{venda_id} | Status: {venda.status} | Total: R$ {float(venda.total):.2f} | Pago: R$ {total_pagamentos:.2f}")
    
    # Adicionar informa√ß√µes de lembretes no retorno
    venda_dict = venda.to_dict()
    if lembretes_criados or lembretes_atualizados:
        venda_dict['lembretes'] = {
            "criados": lembretes_criados,
            "atualizados": lembretes_atualizados
        }
    
    return venda_dict
    
    except HTTPException:
        # Re-raise HTTP exceptions (valida√ß√µes de neg√≥cio)
        raise
    except Exception as e:
        # üîí ROLLBACK AUTOM√ÅTICO em erro cr√≠tico
        db.rollback()
        logger.error(f"‚ùå ERRO CR√çTICO ao finalizar venda #{venda_id}: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Erro ao finalizar venda: {str(e)}"
        )


@router.post('/{venda_id}/cancelar')
def cancelar_venda(
    venda_id: int,
    dados: CancelarVendaRequest,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Cancela uma venda"""
    venda = db.query(Venda).filter_by(
        id=venda_id,
        user_id=current_user.id
    ).first()
    
    if not venda:
        raise HTTPException(status_code=404, detail='Venda n√£o encontrada')
    
    if venda.status == 'cancelada':
        raise HTTPException(status_code=400, detail='Venda j√° est√° cancelada')
    
    venda.status = 'cancelada'
    venda.cancelada_por = current_user.id
    venda.motivo_cancelamento = dados.motivo
    venda.updated_at = datetime.now()
    
    db.commit()
    db.refresh(venda)
    
    log_action(db, current_user.id, 'UPDATE', 'vendas', venda.id,
               details=f'Venda {venda.numero_venda} cancelada - Motivo: {dados.motivo}')
    
    return venda.to_dict()


@router.post('/{venda_id}/reabrir')
def reabrir_venda(
    venda_id: int,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Reabre uma venda finalizada (muda status para aberta)"""
    venda = db.query(Venda).filter_by(
        id=venda_id,
        user_id=current_user.id
    ).first()
    
    if not venda:
        raise HTTPException(status_code=404, detail='Venda n√£o encontrada')
    
    # Impedir reabertura de vendas com NF emitida
    if venda.status == 'pago_nf':
        raise HTTPException(
            status_code=400, 
            detail='N√£o √© poss√≠vel reabrir uma venda com NF-e emitida. Cancele a nota fiscal primeiro.'
        )
    
    # Permitir reabrir vendas finalizadas ou parcialmente pagas
    if venda.status not in ['finalizada', 'baixa_parcial']:
        raise HTTPException(
            status_code=400, 
            detail='Apenas vendas finalizadas ou com baixa parcial podem ser reabertas'
        )
    
    # Guardar status anterior para log
    status_anterior = venda.status
    
    # Mudar status para aberta
    venda.status = 'aberta'
    venda.data_finalizacao = None
    venda.updated_at = datetime.now()
    
    db.commit()
    db.refresh(venda)
    
    log_action(
        db=db,
        user_id=current_user.id,
        action='update',
        entity_type='vendas',
        entity_id=venda.id,
        details=f'Venda #{venda.id} reaberta (status: {status_anterior} ‚Üí aberta)'
    )
    
    return venda.to_dict()


@router.patch('/{venda_id}/status')
def atualizar_status_venda(
    venda_id: int,
    status_data: dict,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Atualiza apenas o status da venda"""
    # Buscar a venda
    venda = db.query(Venda).filter_by(
        id=venda_id,
        user_id=current_user.id
    ).first()
    
    if not venda:
        raise HTTPException(status_code=404, detail='Venda n√£o encontrada')
    
    # Extrair status do body
    novo_status = status_data.get('status')
    if not novo_status:
        raise HTTPException(status_code=400, detail='Status n√£o informado')
    
    status_anterior = venda.status
    venda.status = novo_status
    venda.updated_at = datetime.now()
    
    # üÜï GERAR COMISS√ïES se estiver finalizando a venda (apenas se funcion√°rio/veterin√°rio foi selecionado)
    if novo_status == 'finalizada' and status_anterior != 'finalizada' and venda.funcionario_id:
        try:
            from app.comissoes_service import gerar_comissoes_venda
            
            resultado = gerar_comissoes_venda(
                venda_id=venda.id,
                funcionario_id=venda.funcionario_id,  # Usar funcionario_id, n√£o vendedor_id
                valor_pago=None,  # Considera venda totalmente paga
                db=db
            )
            
            if resultado and resultado.get('success'):
                total_com = resultado.get('total_comissao', 0)
                print(f"üí∞ Comiss√µes geradas: R$ {total_com:.2f}")
            else:
                print("‚ÑπÔ∏è  Nenhuma comiss√£o gerada (sem configura√ß√£o)")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao gerar comiss√µes para venda {venda.id}: {str(e)}")
            # N√£o abortar a atualiza√ß√£o por erro nas comiss√µes
    
    db.commit()
    db.refresh(venda)
    
    log_action(
        db=db,
        user_id=current_user.id,
        action='update',
        entity_type='vendas',
        entity_id=venda.id,
        details=f'Status da venda #{venda.id} alterado: {status_anterior} ‚Üí {novo_status}'
    )
    
    return {'success': True, 'status': novo_status}
    
    return {'message': 'Status atualizado com sucesso', 'status': venda.status}


@router.get('/{venda_id}/pagamentos')
def listar_pagamentos_venda(
    venda_id: int,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Lista todos os pagamentos de uma venda"""
    venda = db.query(Venda).filter_by(
        id=venda_id,
        user_id=current_user.id
    ).first()
    
    if not venda:
        raise HTTPException(status_code=404, detail='Venda n√£o encontrada')
    
    pagamentos = db.query(VendaPagamento).filter_by(venda_id=venda.id).order_by(VendaPagamento.data_pagamento).all()
    
    total_pago = sum(float(p.valor) for p in pagamentos)
    valor_restante = float(venda.total) - total_pago
    
    return {
        'venda_id': venda.id,
        'numero_venda': venda.numero_venda,
        'total_venda': float(venda.total),
        'total_pago': total_pago,
        'valor_restante': max(0, valor_restante),
        'status': venda.status,
        'pagamentos': [p.to_dict() for p in pagamentos]
    }


@router.delete('/pagamentos/{pagamento_id}')
def excluir_pagamento(
    pagamento_id: int,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Excluir um pagamento de uma venda"""
    # Buscar o pagamento
    pagamento = db.query(VendaPagamento).filter_by(id=pagamento_id).first()
    
    if not pagamento:
        raise HTTPException(status_code=404, detail='Pagamento n√£o encontrado')
    
    # Buscar a venda
    venda = db.query(Venda).filter_by(id=pagamento.venda_id, user_id=current_user.id).first()
    
    if not venda:
        raise HTTPException(status_code=404, detail='Venda n√£o encontrada')
    
    # Impedir exclus√£o de pagamento em vendas com NF emitida
    if venda.status == 'pago_nf':
        raise HTTPException(
            status_code=400,
            detail='N√£o √© poss√≠vel excluir pagamentos de uma venda com NF-e emitida. Cancele a nota fiscal primeiro.'
        )
    
    # ‚ö†Ô∏è IMPORTANTE: Se venda est√° finalizada/baixa_parcial, n√£o pode excluir pagamento
    # Usu√°rio deve REABRIR a venda primeiro!
    if venda.status in ['finalizada', 'baixa_parcial']:
        raise HTTPException(
            status_code=400,
            detail='N√£o √© poss√≠vel excluir pagamentos de uma venda finalizada. Reabra a venda primeiro atrav√©s do bot√£o "Reabrir Venda".'
        )
    
    # Registrar auditoria
    try:
        log_action(
            db=db,
            user_id=current_user.id,
            action='delete',
            entity_type='venda_pagamentos',
            entity_id=pagamento.id,
            details=f'Exclu√≠do pagamento de R$ {pagamento.valor} ({pagamento.forma_pagamento}) da venda #{venda.id}'
        )
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao registrar auditoria: {e}")
    
    # Sincronizar exclus√£o com contas a receber e lan√ßamentos manuais
    try:
        contas = db.query(ContaReceber).filter(ContaReceber.venda_id == venda.id).all()
        
        for conta in contas:
            # Deletar conta a receber
            try:
                db.delete(conta)
                print(f"üóëÔ∏è Conta a receber {conta.id} exclu√≠da")
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao deletar conta: {e}")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao buscar contas a receber: {e}")
    
    # Excluir o pagamento
    db.delete(pagamento)
    db.flush()  # Garantir que o delete seja processado antes da query
    
    # Recalcular total pago
    pagamentos_restantes = db.query(VendaPagamento).filter_by(venda_id=venda.id).all()
    total_pago = sum(float(p.valor) for p in pagamentos_restantes)
    total_venda = float(venda.total)
    
    print(f"DEBUG excluir_pagamento: total_pago={total_pago}, total_venda={total_venda}")
    
    # Atualizar status da venda
    if total_pago == 0:
        venda.status = 'aberta'
        print(f"DEBUG: Mudou status para ABERTA (total_pago = 0)")
    elif total_pago >= total_venda:
        venda.status = 'finalizada'
        print(f"DEBUG: Mudou status para FINALIZADA (total_pago >= total_venda)")
    else:
        venda.status = 'baixa_parcial'
        print(f"DEBUG: Mudou status para BAIXA_PARCIAL")
    
    db.commit()
    
    return {
        'message': 'Pagamento exclu√≠do com sucesso',
        'venda_id': venda.id,
        'novo_status': venda.status,
        'total_pago': total_pago,
        'valor_restante': max(0, total_venda - total_pago)
    }


@router.delete('/{venda_id}')
def excluir_venda(
    venda_id: int,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Excluir uma venda e devolver estoque"""
    # Buscar a venda
    venda = db.query(Venda).filter_by(id=venda_id, user_id=current_user.id).first()
    
    if not venda:
        raise HTTPException(status_code=404, detail='Venda n√£o encontrada')
    
    # Verificar se a venda tem NF emitida
    if venda.status == 'pago_nf':
        raise HTTPException(
            status_code=400,
            detail='N√£o √© poss√≠vel excluir uma venda com NF-e emitida. Cancele a nota fiscal primeiro.'
        )
    
    # Verificar se a venda est√° finalizada
    if venda.status == 'finalizada':
        raise HTTPException(
            status_code=400, 
            detail='N√£o √© poss√≠vel excluir uma venda finalizada. Estorne os pagamentos primeiro.'
        )
    
    # Devolver estoque dos produtos
    itens = db.query(VendaItem).filter_by(venda_id=venda_id).all()
    
    for item in itens:
        produto = db.query(Produto).filter_by(id=item.produto_id).first()
        if produto:
            # üîß FIX: Converter para float para evitar erro de tipo
            produto.estoque_atual += float(item.quantidade)
            
            # Registrar auditoria do estoque
            log_action(
                db=db,
                user_id=current_user.id,
                action='update',
                entity_type='produtos',
                entity_id=produto.id,
                details=f'Estorno de estoque (+{item.quantidade}) - Venda #{venda_id} exclu√≠da'
            )
    
    # Registrar auditoria da venda
    log_action(
        db=db,
        user_id=current_user.id,
        action='delete',
        entity_type='vendas',
        entity_id=venda.id,
        details=f'Venda #{venda.id} exclu√≠da - Total: R$ {venda.total} - {len(itens)} itens'
    )
    
    # üí∞ IMPORTANTE: Excluir movimenta√ß√µes de caixa relacionadas
    from app.caixa_models import MovimentacaoCaixa
    movimentacoes = db.query(MovimentacaoCaixa).filter_by(venda_id=venda_id).all()
    for mov in movimentacoes:
        print(f"üóëÔ∏è Removendo movimenta√ß√£o de caixa: R$ {mov.valor} ({mov.tipo})")
        db.delete(mov)
    
    # üè¶ ESTORNAR MOVIMENTA√á√ïES BANC√ÅRIAS
    from app.financeiro_models import MovimentacaoFinanceira, ContaBancaria, LancamentoManual
    
    movimentacoes_bancarias = db.query(MovimentacaoFinanceira).filter_by(venda_id=venda_id).all()
    for mov_banc in movimentacoes_bancarias:
        # Estornar saldo da conta banc√°ria
        conta_bancaria = db.query(ContaBancaria).get(mov_banc.conta_bancaria_id)
        if conta_bancaria:
            if mov_banc.tipo == 'receita':
                conta_bancaria.saldo_atual -= mov_banc.valor
                print(f"üè¶ Estornando saldo banc√°rio: {conta_bancaria.nome} -R$ {mov_banc.valor}")
            elif mov_banc.tipo == 'despesa':
                conta_bancaria.saldo_atual += mov_banc.valor
                print(f"üè¶ Estornando saldo banc√°rio: {conta_bancaria.nome} +R$ {mov_banc.valor}")
        
        db.delete(mov_banc)
    
    # üìä CANCELAR LAN√áAMENTOS MANUAIS (Fluxo de Caixa)
    # Buscar por documento VENDA-{id} ou por venda vinculada
    lancamentos = db.query(LancamentoManual).filter(
        or_(
            LancamentoManual.documento == f"VENDA-{venda_id}",
            LancamentoManual.documento.like(f"VENDA-{venda_id}-%")
        )
    ).all()
    
    for lanc in lancamentos:
        if lanc.status == 'previsto':
            # Apenas remover se ainda n√£o foi realizado
            print(f"üìä Removendo lan√ßamento previsto: {lanc.descricao} - R$ {lanc.valor}")
            db.delete(lanc)
        elif lanc.status == 'realizado':
            # Marcar como cancelado (manter hist√≥rico)
            lanc.status = 'cancelado'
            print(f"üìä Cancelando lan√ßamento realizado: {lanc.descricao} - R$ {lanc.valor}")
    
    # Excluir pagamentos (se houver)
    db.query(VendaPagamento).filter_by(venda_id=venda_id).delete()
    
    # Excluir/Cancelar contas a receber vinculadas
    contas_receber = db.query(ContaReceber).filter_by(venda_id=venda_id).all()
    for conta in contas_receber:
        if conta.status == 'pendente' or conta.status == 'parcial':
            # Pode excluir contas pendentes
            print(f"üí≥ Removendo conta a receber: {conta.descricao} - R$ {conta.valor_original}")
            db.delete(conta)
        elif conta.status == 'recebido':
            # Marcar como cancelada (manter hist√≥rico)
            conta.status = 'cancelado'
            print(f"üí≥ Cancelando conta j√° recebida: {conta.descricao} - R$ {conta.valor_recebido}")
    
    # Excluir itens
    db.query(VendaItem).filter_by(venda_id=venda_id).delete()
    
    # Excluir venda
    db.delete(venda)
    db.commit()
    
    return {
        'message': 'Venda exclu√≠da com sucesso',
        'itens_devolvidos': len(itens)
    }


@router.post('/{venda_id}/devolucao')
def registrar_devolucao(
    venda_id: int,
    dados: dict,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Registrar devolu√ß√£o de itens de uma venda"""
    try:
        print(f"\n{'='*80}")
        print(f"üîÑ INICIANDO DEVOLU√á√ÉO - Venda #{venda_id}")
        print(f"{'='*80}")
        print(f"üì¶ Dados recebidos: {dados}")
        print(f"üë§ Usu√°rio: {current_user.nome} (ID: {current_user.id})")
        
        # Buscar a venda
        venda = db.query(Venda).filter_by(id=venda_id, user_id=current_user.id).first()
        
        if not venda:
            print(f"‚ùå Venda #{venda_id} n√£o encontrada")
            raise HTTPException(status_code=404, detail='Venda n√£o encontrada')
        
        print(f"‚úÖ Venda encontrada: #{venda.numero_venda} - Total: R$ {venda.total}")
        
        caixa_id = dados.get('caixa_id')
        itens_devolucao = dados.get('itens', [])
        motivo = dados.get('motivo', '')
        gerar_credito = dados.get('gerar_credito', False)  # üÜï Nova op√ß√£o
        
        print(f"üí∞ Modo: {'CR√âDITO ao cliente' if gerar_credito else 'DINHEIRO'}")
        print(f"üìù Motivo: {motivo}")
        print(f"üì¶ Itens para devolu√ß√£o: {len(itens_devolucao)}")
        
        if not caixa_id and not gerar_credito:
            print(f"‚ùå Caixa ID n√£o fornecido para devolu√ß√£o em dinheiro")
            raise HTTPException(status_code=400, detail='ID do caixa √© obrigat√≥rio para devolu√ß√£o em dinheiro')
        
        if not itens_devolucao:
            print(f"‚ùå Nenhum item selecionado")
            raise HTTPException(status_code=400, detail='Nenhum item selecionado para devolu√ß√£o')
        
        if not motivo:
            print(f"‚ùå Motivo n√£o fornecido")
            raise HTTPException(status_code=400, detail='Motivo da devolu√ß√£o √© obrigat√≥rio')
        
        # Verificar se o caixa existe e est√° aberto (apenas se for devolu√ß√£o em dinheiro)
        from app.caixa_models import Caixa, MovimentacaoCaixa
        caixa = None
        if not gerar_credito:
            caixa = db.query(Caixa).filter_by(id=caixa_id, status='aberto').first()
            
            if not caixa:
                raise HTTPException(status_code=400, detail='Caixa n√£o encontrado ou n√£o est√° aberto')
        
        valor_total_devolucao = 0
        itens_devolvidos = []
        
        # Processar cada item devolvido
        for item_dev in itens_devolucao:
            item_id = item_dev.get('item_id')
            quantidade_devolvida = float(item_dev.get('quantidade', 0))
            
            if quantidade_devolvida <= 0:
                continue
            
            # Buscar o item da venda
            item_venda = db.query(VendaItem).filter_by(id=item_id, venda_id=venda_id).first()
            
            if not item_venda:
                raise HTTPException(status_code=404, detail=f'Item {item_id} n√£o encontrado na venda')
            
            if quantidade_devolvida > item_venda.quantidade:
                raise HTTPException(
                    status_code=400,
                    detail=f'Quantidade devolvida ({quantidade_devolvida}) maior que quantidade vendida ({item_venda.quantidade})'
                )
            
            # Devolver ao estoque
            produto = db.query(Produto).filter_by(id=item_venda.produto_id).first()
            if produto:
                produto.estoque_atual += quantidade_devolvida
                
                # Registrar auditoria
                log_action(
                    db=db,
                    user_id=current_user.id,
                    action='update',
                    entity_type='produtos',
                    entity_id=produto.id,
                    details=f'Devolu√ß√£o de estoque (+{quantidade_devolvida}) - Venda #{venda_id} - Motivo: {motivo}'
                )
            
            # Calcular valor devolvido
            valor_item = item_venda.preco_unitario * Decimal(str(quantidade_devolvida))
            valor_total_devolucao += valor_item
            
            itens_devolvidos.append({
                'produto_id': item_venda.produto_id,
                'produto_nome': item_venda.produto.nome if item_venda.produto else item_venda.servico_descricao,
                'quantidade': quantidade_devolvida,
                'valor_unitario': item_venda.preco_unitario,
                'valor_total': valor_item
            })
        
        # üí∞ OP√á√ÉO 1: GERAR CR√âDITO PARA O CLIENTE
        if gerar_credito:
            if not venda.cliente_id:
                raise HTTPException(
                    status_code=400,
                    detail='N√£o √© poss√≠vel gerar cr√©dito para venda sem cliente cadastrado'
                )
            
            from app.models import Cliente
            cliente = db.query(Cliente).get(venda.cliente_id)
            if not cliente:
                raise HTTPException(status_code=404, detail='Cliente n√£o encontrado')
            
            # Adicionar cr√©dito ao cliente
            cliente.credito = (cliente.credito or Decimal('0')) + Decimal(str(valor_total_devolucao))
            print(f"üí∞ Cr√©dito adicionado ao cliente {cliente.nome}: +R$ {valor_total_devolucao:.2f} (Total: R$ {cliente.credito:.2f})")
            
            # N√£o cria MovimentacaoCaixa nem LancamentoManual (apenas cr√©dito)
            
        # üíµ OP√á√ÉO 2: DEVOLU√á√ÉO EM DINHEIRO
        else:
            # Verificar se o caixa existe e est√° aberto
            from app.caixa_models import Caixa
            caixa = db.query(Caixa).filter_by(id=caixa_id, status='aberto').first()
            
            if not caixa:
                raise HTTPException(status_code=400, detail='Caixa n√£o encontrado ou n√£o est√° aberto')
            
            # Registrar movimenta√ß√£o no caixa (devolu√ß√£o em dinheiro)
            movimentacao = MovimentacaoCaixa(
                caixa_id=caixa_id,
                tipo='devolucao',
                valor=valor_total_devolucao,
                forma_pagamento='Dinheiro',
                descricao=f'Devolu√ß√£o da venda #{venda.numero_venda} - {motivo}',
                venda_id=venda_id,
                usuario_id=current_user.id,
                usuario_nome=current_user.nome
            )
            db.add(movimentacao)
            
            # Criar lan√ßamento manual de sa√≠da (estorno no fluxo de caixa)
            from app.financeiro_models import LancamentoManual, CategoriaFinanceira
            
            categoria_devolucoes = db.query(CategoriaFinanceira).filter(
                CategoriaFinanceira.nome.ilike('%devolu√ß√£o%'),
                CategoriaFinanceira.tipo == 'despesa'
            ).first()
            
            if not categoria_devolucoes:
                categoria_devolucoes = CategoriaFinanceira(
                    nome="Devolu√ß√µes de Vendas",
                    tipo="despesa",
                    user_id=current_user.id
                )
                db.add(categoria_devolucoes)
                db.flush()
            
            lancamento_devolucao = LancamentoManual(
                tipo='saida',
                valor=Decimal(str(valor_total_devolucao)),
                descricao=f"Devolu√ß√£o venda {venda.numero_venda} - {motivo}",
                data_lancamento=date.today(),
                status='realizado',
                categoria_id=categoria_devolucoes.id,
                documento=f"DEVOLUCAO-{venda_id}",
                fornecedor_cliente=venda.cliente.nome if venda.cliente else "Cliente Avulso",
                user_id=current_user.id
            )
            db.add(lancamento_devolucao)
            print(f"üìä Lan√ßamento de devolu√ß√£o criado: R$ {valor_total_devolucao:.2f}")
        
        # üÜï AJUSTAR CONTAS A RECEBER (sempre, independente de cr√©dito ou dinheiro)
        from app.financeiro_models import ContaReceber, LancamentoManual, CategoriaFinanceira
        
        contas_receber = db.query(ContaReceber).filter_by(venda_id=venda_id).all()
        if contas_receber:
            # Reduzir proporcionalmente o valor das contas pendentes ou estornar pagas
            for conta in contas_receber:
                if conta.status in ['pendente', 'parcial']:
                    proporcao = valor_total_devolucao / float(venda.total)
                    reducao = float(conta.valor_original) * proporcao
                    
                    conta.valor_original -= Decimal(str(reducao))
                    conta.valor_final -= Decimal(str(reducao))
                    
                    # Se ficou zerada, marcar como cancelada
                    if conta.valor_final <= 0:
                        conta.status = 'cancelada'
                    
                    print(f"üí≥ Ajustando ContaReceber #{conta.id}: -R$ {reducao:.2f}")
                elif conta.status == 'pago':
                    # Cancelar a conta paga (estorno)
                    conta.status = 'estornada'
                    print(f"üí≥ Estornando ContaReceber #{conta.id} (paga)")
        
        # üÜï ESTORNAR LAN√áAMENTOS MANUAIS REALIZADOS (Fluxo de Caixa)
        lancamentos = db.query(LancamentoManual).filter(
            LancamentoManual.documento == f"VENDA-{venda_id}",
            LancamentoManual.status == 'realizado'
        ).all()
        
        if lancamentos:
            # Buscar ou criar categoria de devolu√ß√µes
            categoria_devolucoes = db.query(CategoriaFinanceira).filter(
                CategoriaFinanceira.nome.ilike('%devolu√ß√£o%'),
                CategoriaFinanceira.tipo == 'despesa',
                CategoriaFinanceira.user_id == current_user.id
            ).first()
            
            if not categoria_devolucoes:
                categoria_devolucoes = CategoriaFinanceira(
                    nome="Devolu√ß√µes de Vendas",
                    tipo="despesa",
                    user_id=current_user.id
                )
                db.add(categoria_devolucoes)
                db.flush()
            
            for lanc in lancamentos:
                proporcao = valor_total_devolucao / float(venda.total)
                estorno = float(lanc.valor) * proporcao
                
                # Criar lan√ßamento de estorno (sa√≠da)
                estorno_lanc = LancamentoManual(
                    tipo='saida',
                    valor=Decimal(str(estorno)),
                    descricao=f"Estorno devolu√ß√£o venda {venda.numero_venda} - {motivo}",
                    data_lancamento=date.today(),
                    status='realizado',
                    categoria_id=categoria_devolucoes.id,
                    documento=f"ESTORNO-VENDA-{venda_id}",
                    fornecedor_cliente=venda.cliente.nome if venda.cliente else "Cliente Avulso",
                    user_id=current_user.id
                )
                db.add(estorno_lanc)
                print(f"üí∏ Estorno criado no LancamentoManual: -R$ {estorno:.2f}")
        
        # üÜï ATUALIZAR STATUS DA VENDA
        if valor_total_devolucao >= float(venda.total) * 0.99:  # 99% devolvido = total
            venda.status = 'finalizada_devolucao_total'
        else:
            venda.status = 'finalizada_devolucao_parcial'
        
        # Registrar auditoria da devolu√ß√£o
        tipo_devolucao = "Cr√©dito ao cliente" if gerar_credito else "Dinheiro"
        log_action(
            db=db,
            user_id=current_user.id,
            action='devolucao',
            entity_type='vendas',
            entity_id=venda_id,
            details=f'Devolu√ß√£o registrada ({tipo_devolucao}) - Venda #{venda_id} - R$ {valor_total_devolucao:.2f} - Motivo: {motivo}'
        )
        
        db.commit()
        
        resultado = {
            'message': 'Devolu√ß√£o registrada com sucesso',
            'venda_id': venda_id,
            'valor_total_devolucao': valor_total_devolucao,
            'tipo_devolucao': tipo_devolucao,
            'status_venda': venda.status,
            'itens_devolvidos': itens_devolvidos
        }
        
        if gerar_credito:
            from app.models import Cliente
            cliente = db.query(Cliente).get(venda.cliente_id)
            resultado['credito_cliente'] = float(cliente.credito)
            resultado['cliente_nome'] = cliente.nome
        else:
            resultado['movimentacao_caixa_id'] = movimentacao.id
        
        print(f"‚úÖ Devolu√ß√£o conclu√≠da com sucesso!")
        print(f"{'='*80}\n")
        return resultado
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"\n{'='*80}")
        print(f"üö® ERRO CR√çTICO NA DEVOLU√á√ÉO:")
        print(f"{'='*80}")
        print(f"Tipo: {type(e).__name__}")
        print(f"Mensagem: {str(e)}")
        import traceback
        print(f"Traceback completo:")
        traceback.print_exc()
        print(f"{'='*80}\n")
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Erro ao processar devolu√ß√£o: {str(e)}")


# ============================================================================
# ENDPOINTS - RELAT√ìRIOS
# ============================================================================

@router.get('/relatorios/resumo')
def relatorio_resumo(
    data_inicio: Optional[str] = None,
    data_fim: Optional[str] = None,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """Relat√≥rio resumo de vendas"""
    query = db.query(Venda).filter_by(user_id=current_user.id)
    
    if data_inicio:
        data_inicio_dt = datetime.strptime(data_inicio, '%Y-%m-%d')
        query = query.filter(Venda.data_venda >= data_inicio_dt)
    
    if data_fim:
        data_fim_dt = datetime.strptime(data_fim, '%Y-%m-%d')
        data_fim_dt = data_fim_dt.replace(hour=23, minute=59, second=59)
        query = query.filter(Venda.data_venda <= data_fim_dt)
    
    vendas = query.all()
    
    # Calcular resumo
    total_vendas = len(vendas)
    total_valor = sum(float(v.total) for v in vendas if v.status != 'cancelada')
    total_canceladas = sum(1 for v in vendas if v.status == 'cancelada')
    
    # Por forma de pagamento
    pagamentos_resumo = {}
    for venda in vendas:
        if venda.status != 'cancelada':
            for pag in venda.pagamentos:
                forma = pag.forma_pagamento
                if forma not in pagamentos_resumo:
                    pagamentos_resumo[forma] = 0
                pagamentos_resumo[forma] += float(pag.valor)
    
    return {
        'total_vendas': total_vendas,
        'total_valor': total_valor,
        'total_canceladas': total_canceladas,
        'pagamentos_resumo': pagamentos_resumo,
        'periodo': {
            'inicio': data_inicio if data_inicio else None,
            'fim': data_fim if data_fim else None
        }
    }
